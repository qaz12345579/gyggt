-- ğŸ”¥ ëª¨ë°”ì¼ ìµœì í™” ê·¹ê°• ì „íˆ¬ ìŠ¤í¬ë¦½íŠ¸ ğŸ”¥
local rs = game:GetService("ReplicatedStorage")
local ps = game:GetService("Players")
local cam = workspace.CurrentCamera
local runService = game:GetService("RunService")
local uis = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")
local http = game:GetService("HttpService")

-- ë¡œì»¬ í”Œë ˆì´ì–´
local lp = ps.LocalPlayer
local mouse = lp:GetMouse()

-- ëª¨ë°”ì¼ ì²´í¬
local IS_MOBILE = uis.TouchEnabled
if not IS_MOBILE then
    warn("ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ëª¨ë°”ì¼ìš©ì…ë‹ˆë‹¤!")
    return
end

-- ê²Œì„ì— í•„ìš”í•œ ëª¨ë“ˆ ì°¾ê¸°
local CombatModule = nil
local NetworkModule = nil

-- ëª¨ë“ˆ ìë™ íƒìƒ‰
for _, v in pairs(rs:GetDescendants()) do
    if v:IsA("ModuleScript") then
        if string.find(v.Name:lower(), "combat") or string.find(v.Name:lower(), "weapon") then
            pcall(function() CombatModule = require(v) end)
        end
        if string.find(v.Name:lower(), "network") or string.find(v.Name:lower(), "remote") then
            pcall(function() NetworkModule = require(v) end)
        end
    end
end

-- ëª¨ë°”ì¼ì„ ìœ„í•œ ê·¹ê°• ì„¤ì •
local SETTINGS = {
    -- ğŸ”¥ í•µì‹¬ ê¸°ëŠ¥
    MASTER_SWITCH = true, -- ì „ì²´ ì‹œìŠ¤í…œ ON/OFF
    FORCE_HEADSHOT = true, -- ë¬´ì¡°ê±´ í—¤ë“œìƒ·
    PERFECT_AIM = true, -- 100% ì •í™•ë„
    INSTANT_HIT = true, -- ì¦‰ì‹œ íƒ€ê²© (íƒ„ì† ë¬´í•œëŒ€)
    
    -- ğŸ¯ ì¡°ì¤€ ì„¤ì •
    AIM_ASSIST = 1.0, -- ì¡°ì¤€ ë³´ì¡° ê°•ë„ (ìµœëŒ€)
    SMOOTHING = 0.1, -- ë¶€ë“œëŸ¬ì›€
    PREDICTION = 0.2, -- ì´ë™ ì˜ˆì¸¡
    FOV = 360, -- ì‹œì•¼ê° 360ë„ (ì‚¬ë°©íŒ”ë°©)
    LOCK_ON = true, -- íƒ€ê²Ÿ ê³ ì •
    AUTO_SWITCH = true, -- íƒ€ê²Ÿ ìë™ ì „í™˜
    
    -- ğŸ”« ì‚¬ê²© ì„¤ì •
    RAPID_FIRE = true, -- ì—°ì‚¬ì†ë„ ì¦ê°€
    RAPID_MULTIPLIER = 5, -- ì—°ì‚¬ì†ë„ ë°°ìˆ˜ (5ë°°)
    NO_RECOIL = true, -- ë°˜ë™ ì œê±°
    NO_SPREAD = true, -- íƒ„í¼ì§ ì œê±°
    INFINITE_AMMO = true, -- ë¬´í•œ íƒ„ì•½
    NO_RELOAD = true, -- ì¬ì¥ì „ ì—†ìŒ
    
    -- ğŸ° ë²½ ê´€ë ¨
    WALLBANG = true, -- ë²½ ëš«ê¸°
    PENETRATION = 10, -- ê´€í†µë ¥ (10ê°œì˜ ë²½ê¹Œì§€)
    THROUGH_WALLS = true, -- ëª¨ë“  ë²½ ë¬´ì‹œ
    IGNORE_COVER = true, -- ì—„íë¬¼ ë¬´ì‹œ
    
    -- ğŸ‘ï¸ ESP ì„¤ì •
    ESP_ENABLED = true,
    BOX_ESP = true,
    NAME_TAGS = true,
    HEALTH_BAR = true,
    DISTANCE = true,
    TRACERS = true,
    SNAPLINES = true, -- ì¡°ì¤€ì„  í‘œì‹œ
    RADAR = true, -- ë¯¸ë‹ˆë§µ
    
    -- ğŸ“± ëª¨ë°”ì¼ íŠ¹í™”
    TOUCH_AIM = true, -- í„°ì¹˜ ì¡°ì¤€
    AUTO_FIRE = true, -- ìë™ ë°œì‚¬
    GYRO_AIM = false, -- ìì´ë¡œ ì„¼ì„œ ì¡°ì¤€
    SIMPLE_UI = true, -- ë‹¨ìˆœí™”ëœ UI
}

-- ê¸€ë¡œë²Œ ë³€ìˆ˜
local Target = nil
local TargetPart = nil
local TargetDistance = 0
local Aiming = false
local Firing = false
local ESPCache = {}
local RemoteHooks = {}
local OriginalFunctions = {}

-- ğŸ”¥ í•µì‹¬: íƒ€ê²Ÿ ì°¾ê¸° í•¨ìˆ˜ (ê·¹ê°• ë²„ì „)
local function FindBestTarget()
    if not SETTINGS.MASTER_SWITCH then return nil, nil end
    
    local Character = lp.Character
    if not Character then return nil, nil end
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return nil, nil end
    
    local MyPosition = HumanoidRootPart.Position
    local BestTarget = nil
    local BestPart = nil
    local BestScore = -999999
    
    -- ëª¨ë“  í”Œë ˆì´ì–´ ê²€ì‚¬
    for _, Player in pairs(ps:GetPlayers()) do
        if Player == lp then continue end
        
        local TargetCharacter = Player.Character
        if not TargetCharacter then continue end
        
        local TargetRoot = TargetCharacter:FindFirstChild("HumanoidRootPart")
        local TargetHumanoid = TargetCharacter:FindFirstChildOfClass("Humanoid")
        local TargetHead = TargetCharacter:FindFirstChild("Head")
        
        if TargetRoot and TargetHumanoid and TargetHumanoid.Health > 0 then
            -- ê±°ë¦¬ ê³„ì‚°
            local Distance = (TargetRoot.Position - MyPosition).Magnitude
            if Distance > 5000 then continue end -- 5000 ìŠ¤í„°ë“œ ì´ë‚´
            
            -- ë²½ ì²´í¬ (ë²½ ëš«ê¸° ëª¨ë“œì¼ ê²½ìš° ë¬´ì‹œ)
            local IsVisible = true
            if not SETTINGS.THROUGH_WALLS then
                local RayParams = RaycastParams.new()
                RayParams.FilterDescendantsInstances = {Character, TargetCharacter}
                RayParams.FilterType = Enum.RaycastFilterType.Exclude
                
                local RayResult = workspace:Raycast(MyPosition, TargetRoot.Position - MyPosition, RayParams)
                if RayResult and RayResult.Instance and not RayResult.Instance:IsDescendantOf(TargetCharacter) then
                    IsVisible = false
                end
            end
            
            if IsVisible then
                -- ì ìˆ˜ ê³„ì‚° (ê·¹ëŒ€í™”)
                local DistanceScore = 5000 / math.max(Distance, 1) -- ê±°ë¦¬ ê°€ì¤‘ì¹˜ ë†’ì„
                local VisibleScore = IsVisible and 1000 or 0
                local HealthScore = (TargetHumanoid.Health / TargetHumanoid.MaxHealth) * 500
                local PriorityScore = 0
                
                -- í—¤ë“œ ìš°ì„ ìˆœìœ„
                if TargetHead then
                    PriorityScore = 2000
                end
                
                -- ì¡°ì¤€ ì¤‘ì¸ íƒ€ê²Ÿ ë³´ë„ˆìŠ¤
                if Target == TargetCharacter then
                    PriorityScore = PriorityScore + 1000
                end
                
                local TotalScore = DistanceScore + VisibleScore + HealthScore + PriorityScore
                
                if TotalScore > BestScore then
                    BestScore = TotalScore
                    BestTarget = TargetCharacter
                    BestPart = SETTINGS.FORCE_HEADSHOT and TargetHead or TargetRoot
                end
            end
        end
    end
    
    -- NPCë‚˜ ë‹¤ë¥¸ ê°ì²´ë„ ê²€ì‚¬
    for _, Model in pairs(workspace:GetChildren()) do
        if Model:IsA("Model") and Model ~= Character then
            local ModelHumanoid = Model:FindFirstChildOfClass("Humanoid")
            local ModelRoot = Model:FindFirstChild("HumanoidRootPart") or Model:FindFirstChild("Torso")
            
            if ModelHumanoid and ModelRoot and ModelHumanoid.Health > 0 then
                local Distance = (ModelRoot.Position - MyPosition).Magnitude
                if Distance < 1000 then
                    local Score = 3000 / math.max(Distance, 1)
                    if Score > BestScore then
                        BestScore = Score
                        BestTarget = Model
                        BestPart = Model:FindFirstChild("Head") or ModelRoot
                    end
                end
            end
        end
    end
    
    return BestTarget, BestPart
end

-- ğŸ¯ ì¡°ì¤€ ë³´ì¡° í•¨ìˆ˜ (ê·¹ê°• ì •í™•ë„)
local function GetAimCorrection(TargetPart)
    if not TargetPart or not SETTINGS.PERFECT_AIM then
        return Vector3.new(0, 0, 0)
    end
    
    local Character = lp.Character
    if not Character then return Vector3.new(0, 0, 0) end
    
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return Vector3.new(0, 0, 0) end
    
    -- íƒ€ê²Ÿ ìœ„ì¹˜
    local TargetPosition = TargetPart.Position
    
    -- ì´ë™ ì˜ˆì¸¡
    if SETTINGS.PREDICTION > 0 then
        local Velocity = TargetPart.AssemblyLinearVelocity or Vector3.new(0, 0, 0)
        local Distance = (TargetPosition - HumanoidRootPart.Position).Magnitude
        local TimeToTarget = Distance / 1000 -- íƒ„ì† ê°€ì •
        TargetPosition = TargetPosition + (Velocity * TimeToTarget * SETTINGS.PREDICTION)
    end
    
    -- ë¶€ë“œëŸ¬ìš´ ì¡°ì¤€
    local CurrentLook = cam.CFrame.LookVector
    local DesiredLook = (TargetPosition - cam.CFrame.Position).Unit
    
    if SETTINGS.SMOOTHING > 0 then
        DesiredLook = CurrentLook:Lerp(DesiredLook, SETTINGS.SMOOTHING)
    end
    
    return DesiredLook
end

-- ğŸ”« ë°œì‚¬ í•¨ìˆ˜ í›„í‚¹ (ì—°ì‚¬ì†ë„ ì¦ê°€)
local function HookFireFunctions()
    -- RemoteEvent í›„í‚¹
    for _, Remote in pairs(rs:GetDescendants()) do
        if Remote:IsA("RemoteEvent") then
            local Name = Remote.Name:lower()
            if string.find(Name, "fire") or string.find(Name, "shoot") or string.find(Name, "attack") then
                local OriginalFire = Remote.FireServer
                
                RemoteHooks[Remote] = OriginalFire
                
                Remote.FireServer = function(self, ...)
                    local Args = {...}
                    
                    -- ì—°ì‚¬ì†ë„ ì¦ê°€
                    if SETTINGS.RAPID_FIRE then
                        for i = 1, SETTINGS.RAPID_MULTIPLIER do
                            task.spawn(function()
                                OriginalFire(self, unpack(Args))
                            end)
                        end
                        return
                    end
                    
                    -- ë¬´í•œ íƒ„ì•½, ì¬ì¥ì „ ì œê±°
                    if SETTINGS.INFINITE_AMMO or SETTINGS.NO_RELOAD then
                        -- íƒ„ì•½ ê´€ë ¨ ì¸ì ìˆ˜ì • ê°€ëŠ¥
                    end
                    
                    return OriginalFire(self, ...)
                end
                
                print("ğŸ”¥ í›„í‚¹ëœ ë°œì‚¬ ì´ë²¤íŠ¸:", Remote.Name)
            end
        end
    end
    
    -- RemoteFunction í›„í‚¹
    for _, RemoteFunc in pairs(rs:GetDescendants()) do
        if RemoteFunc:IsA("RemoteFunction") then
            local Name = RemoteFunc.Name:lower()
            if string.find(Name, "damage") or string.find(Name, "hit") then
                local OriginalInvoke = RemoteFunc.InvokeServer
                
                RemoteHooks[RemoteFunc] = OriginalInvoke
                
                RemoteFunc.InvokeServer = function(self, ...)
                    local Args = {...}
                    
                    -- ë²½ ëš«ê¸° ì ìš©
                    if SETTINGS.WALLBANG then
                        -- ë°ë¯¸ì§€ ìœ„ì¹˜ë¥¼ íƒ€ê²Ÿ ìœ„ì¹˜ë¡œ ë³€ê²½
                        if Target and TargetPart then
                            Args[2] = TargetPart.Position -- ê°€ì •: ë‘ ë²ˆì§¸ ì¸ìê°€ ìœ„ì¹˜
                        end
                    end
                    
                    return OriginalInvoke(self, unpack(Args))
                end
                
                print("ğŸ¯ í›„í‚¹ëœ ë°ë¯¸ì§€ í•¨ìˆ˜:", RemoteFunc.Name)
            end
        end
    end
end

-- ğŸ° Raycast í›„í‚¹ (ë²½ ëš«ê¸° í•µì‹¬)
local function HookRaycast()
    local OriginalRaycast = workspace.Raycast
    local OriginalFindPartOnRay = workspace.FindPartOnRay
    
    workspace.Raycast = function(workspace, origin, direction, raycastParams, ...)
        if not SETTINGS.MASTER_SWITCH then
            return OriginalRaycast(workspace, origin, direction, raycastParams, ...)
        end
        
        -- ë²½ ëš«ê¸° ëª¨ë“œ
        if SETTINGS.WALLBANG then
            raycastParams = raycastParams or RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {}
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        end
        
        -- ì‚¬ì¼ëŸ°íŠ¸ ì—ì„ ì ìš©
        if SETTINGS.PERFECT_AIM and TargetPart then
            local Correction = GetAimCorrection(TargetPart)
            direction = Correction * direction.Magnitude
        end
        
        local Result = OriginalRaycast(workspace, origin, direction, raycastParams, ...)
        
        -- ê²°ê³¼ ê°•ì œ ë³€ê²½ (ë²½ ëš«ê¸°)
        if SETTINGS.THROUGH_WALLS and TargetPart then
            local Distance = (TargetPart.Position - origin).Magnitude
            
            if not Result or (Result and Result.Instance ~= TargetPart) then
                return {
                    Position = TargetPart.Position,
                    Material = TargetPart.Material or Enum.Material.Plastic,
                    Normal = (TargetPart.Position - origin).Unit,
                    Instance = TargetPart,
                    Distance = Distance
                }
            end
        end
        
        return Result
    end
    
    workspace.FindPartOnRay = function(workspace, ray, ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
        if not SETTINGS.MASTER_SWITCH then
            return OriginalFindPartOnRay(workspace, ray, ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
        end
        
        -- ì‚¬ì¼ëŸ°íŠ¸ ì—ì„ ì ìš©
        if SETTINGS.PERFECT_AIM and TargetPart then
            local Correction = GetAimCorrection(TargetPart)
            local NewDirection = Correction * 1000
            ray = Ray.new(ray.Origin, NewDirection)
        end
        
        local Result = OriginalFindPartOnRay(workspace, ray, ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
        
        -- ê²°ê³¼ ê°•ì œ ë³€ê²½
        if SETTINGS.THROUGH_WALLS and TargetPart and Result ~= TargetPart then
            return TargetPart
        end
        
        return Result
    end
    
    print("ğŸ° Raycast í›„í‚¹ ì™„ë£Œ!")
end

-- ğŸ“± ëª¨ë°”ì¼ ì „ìš© í„°ì¹˜ ì»¨íŠ¸ë¡¤
local function CreateMobileControls()
    local MobileGUI = Instance.new("ScreenGui")
    MobileGUI.Name = "MobileCombatGUI"
    MobileGUI.DisplayOrder = 999
    MobileGUI.ResetOnSpawn = false
    
    -- ìƒë‹¨ ì •ë³´ íŒ¨ë„
    local InfoPanel = Instance.new("Frame")
    InfoPanel.Name = "InfoPanel"
    InfoPanel.Size = UDim2.new(1, -40, 0, 80)
    InfoPanel.Position = UDim2.new(0, 20, 0, 10)
    InfoPanel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    InfoPanel.BackgroundTransparency = 0.5
    InfoPanel.BorderSizePixel = 0
    
    local TargetLabel = Instance.new("TextLabel")
    TargetLabel.Name = "TargetLabel"
    TargetLabel.Size = UDim2.new(1, -10, 0, 30)
    TargetLabel.Position = UDim2.new(0, 5, 0, 5)
    TargetLabel.BackgroundTransparency = 1
    TargetLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
    TargetLabel.Font = Enum.Font.GothamBlack
    TargetLabel.TextSize = 16
    TargetLabel.Text = "ğŸ¯ íƒ€ê²Ÿ: ì—†ìŒ"
    TargetLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local StatsLabel = Instance.new("TextLabel")
    StatsLabel.Name = "StatsLabel"
    StatsLabel.Size = UDim2.new(1, -10, 0, 30)
    StatsLabel.Position = UDim2.new(0, 5, 0, 40)
    StatsLabel.BackgroundTransparency = 1
    StatsLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    StatsLabel.Font = Enum.Font.Gotham
    StatsLabel.TextSize = 14
    StatsLabel.Text = "ğŸ”« ì—°ì‚¬: 5x | ğŸ“ ê±°ë¦¬: 0"
    StatsLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ íŒ¨ë„ (ìš°ì¸¡)
    local ControlPanel = Instance.new("Frame")
    ControlPanel.Name = "ControlPanel"
    ControlPanel.Size = UDim2.new(0, 180, 0, 250)
    ControlPanel.Position = UDim2.new(1, -190, 0.5, -125)
    ControlPanel.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    ControlPanel.BackgroundTransparency = 0.3
    ControlPanel.BorderSizePixel = 0
    
    -- ê¸°ëŠ¥ ë²„íŠ¼ ìƒì„± í•¨ìˆ˜
    local function CreateToggleButton(name, text, position, color, settingKey)
        local Button = Instance.new("TextButton")
        Button.Name = name
        Button.Size = UDim2.new(1, -20, 0, 40)
        Button.Position = position
        Button.BackgroundColor3 = color
        Button.TextColor3 = Color3.fromRGB(255, 255, 255)
        Button.Font = Enum.Font.GothamBold
        Button.TextSize = 14
        Button.Text = text
        Button.BorderSizePixel = 0
        
        Button.MouseButton1Click:Connect(function()
            SETTINGS[settingKey] = not SETTINGS[settingKey]
            Button.Text = text .. ": " .. (SETTINGS[settingKey] and "ON" or "OFF")
            Button.BackgroundColor3 = SETTINGS[settingKey] and color or Color3.fromRGB(100, 100, 100)
        end)
        
        return Button
    end
    
    -- ë²„íŠ¼ë“¤ ìƒì„±
    local buttons = {
        {"ë²½ëš«ê¸°", "ğŸ§± ë²½ëš«ê¸°", UDim2.new(0, 10, 0, 10), Color3.fromRGB(255, 50, 50), "WALLBANG"},
        {"ì—°ì‚¬ì†ë„", "âš¡ ì—°ì‚¬ì†ë„", UDim2.new(0, 10, 0, 55), Color3.fromRGB(50, 150, 255), "RAPID_FIRE"},
        {"ìë™ì¡°ì¤€", "ğŸ¯ ìë™ì¡°ì¤€", UDim2.new(0, 10, 0, 100), Color3.fromRGB(50, 255, 50), "PERFECT_AIM"},
        {"í—¤ë“œìƒ·", "ğŸ’€ í—¤ë“œìƒ·", UDim2.new(0, 10, 0, 145), Color3.fromRGB(255, 100, 255), "FORCE_HEADSHOT"},
        {"ì‹œìŠ¤í…œ", "ğŸ”¥ ì‹œìŠ¤í…œ", UDim2.new(0, 10, 0, 190), Color3.fromRGB(255, 150, 50), "MASTER_SWITCH"}
    }
    
    for _, btnInfo in ipairs(buttons) do
        local btn = CreateToggleButton(btnInfo[1], btnInfo[2], btnInfo[3], btnInfo[4], btnInfo[5])
        btn.Parent = ControlPanel
    end
    
    -- í„°ì¹˜ ì¡°ì´ìŠ¤í‹± (ì¢Œì¸¡)
    local TouchStick = Instance.new("Frame")
    TouchStick.Name = "TouchStick"
    TouchStick.Size = UDim2.new(0, 120, 0, 120)
    TouchStick.Position = UDim2.new(0, 30, 1, -150)
    TouchStick.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TouchStick.BackgroundTransparency = 0.8
    TouchStick.BorderSizePixel = 0
    
    local StickDot = Instance.new("Frame")
    StickDot.Name = "StickDot"
    StickDot.Size = UDim2.new(0, 30, 0, 30)
    StickDot.Position = UDim2.new(0.5, -15, 0.5, -15)
    StickDot.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
    StickDot.BackgroundTransparency = 0.5
    StickDot.BorderSizePixel = 0
    
    -- í„°ì¹˜ ì´ë²¤íŠ¸
    local TouchActive = false
    TouchStick.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            TouchActive = true
            StickDot.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
        end
    end)
    
    TouchStick.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            TouchActive = false
            StickDot.Position = UDim2.new(0.5, -15, 0.5, -15)
            StickDot.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        end
    end)
    
    TouchStick.InputChanged:Connect(function(input)
        if TouchActive and input.UserInputType == Enum.UserInputType.Touch then
            local touchPos = input.Position
            local stickPos = TouchStick.AbsolutePosition
            local stickSize = TouchStick.AbsoluteSize
            
            local relativeX = (touchPos.X - stickPos.X) / stickSize.X
            local relativeY = (touchPos.Y - stickPos.Y) / stickSize.Y
            
            relativeX = math.clamp(relativeX, 0, 1)
            relativeY = math.clamp(relativeY, 0, 1)
            
            StickDot.Position = UDim2.new(relativeX, -15, relativeY, -15)
            
            -- ì¡°ì¤€ ë³´ì¡°ì— í™œìš©
            if SETTINGS.TOUCH_AIM then
                local moveVector = Vector2.new(
                    (relativeX - 0.5) * 2,
                    (relativeY - 0.5) * 2
                )
                
                -- ì´ë™ ë²¡í„°ì— ë”°ë¼ ì¹´ë©”ë¼ íšŒì „
                -- (ì‹¤ì œ êµ¬í˜„ì€ ê²Œì„ì— ë”°ë¼ ë‹¤ë¦„)
            end
        end
    end)
    
    -- ìë™ ë°œì‚¬ ë²„íŠ¼
    local AutoFireBtn = Instance.new("TextButton")
    AutoFireBtn.Name = "AutoFireBtn"
    AutoFireBtn.Size = UDim2.new(0, 100, 0, 50)
    AutoFireBtn.Position = UDim2.new(0.5, -50, 1, -70)
    AutoFireBtn.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    AutoFireBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    AutoFireBtn.Font = Enum.Font.GothamBlack
    AutoFireBtn.TextSize = 18
    AutoFireBtn.Text = "ğŸ”« ìë™ ë°œì‚¬"
    AutoFireBtn.BorderSizePixel = 0
    
    local AutoFiring = false
    AutoFireBtn.MouseButton1Down:Connect(function()
        AutoFiring = true
        AutoFireBtn.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    end)
    
    AutoFireBtn.MouseButton1Up:Connect(function()
        AutoFiring = false
        AutoFireBtn.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end)
    
    -- ë¶€ëª¨ ì—°ê²°
    TargetLabel.Parent = InfoPanel
    StatsLabel.Parent = InfoPanel
    StickDot.Parent = TouchStick
    
    InfoPanel.Parent = MobileGUI
    ControlPanel.Parent = MobileGUI
    TouchStick.Parent = MobileGUI
    AutoFireBtn.Parent = MobileGUI
    
    -- GUI ë³´í˜¸ ë° ë¶€ëª¨ ì„¤ì •
    if syn and syn.protect_gui then
        syn.protect_gui(MobileGUI)
        MobileGUI.Parent = game.CoreGui
    else
        MobileGUI.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    end
    
    return {
        GUI = MobileGUI,
        TargetLabel = TargetLabel,
        StatsLabel = StatsLabel,
        AutoFiring = function() return AutoFiring end
    }
end

-- ğŸ‘ï¸ ê°„ë‹¨í•œ ESP (ëª¨ë°”ì¼ ìµœì í™”)
local function CreateSimpleESP(target)
    if not SETTINGS.ESP_ENABLED or ESPCache[target] then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "MobileESP"
    highlight.Adornee = target
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = Color3.fromRGB(255, 50, 50)
    highlight.FillTransparency = 0.7
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.OutlineTransparency = 0
    highlight.Parent = target
    
    -- ê±°ë¦¬ í‘œì‹œ
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "DistanceTag"
    billboard.Size = UDim2.new(0, 100, 0, 30)
    billboard.Adornee = target:WaitForChild("HumanoidRootPart")
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = 1000
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextSize = 12
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Text = target.Parent.Name
    textLabel.Parent = billboard
    
    billboard.Parent = target
    
    ESPCache[target] = {Highlight = highlight, Billboard = billboard}
end

-- ğŸ® ë©”ì¸ ì—…ë°ì´íŠ¸ ë£¨í”„
local MobileUI = CreateMobileControls()
HookFireFunctions()
HookRaycast()

-- ì´ˆê¸°í™” ë©”ì‹œì§€
print("========================================")
print("ğŸ”¥ ëª¨ë°”ì¼ ê·¹ê°• ì „íˆ¬ ì‹œìŠ¤í…œ ë¡œë“œ ì™„ë£Œ! ğŸ”¥")
print("========================================")
print("ê¸°ëŠ¥:")
print("- ì™„ë²½ ë²½ëš«ê¸° (ëª¨ë“  ë²½ í†µê³¼)")
print("- ì´ˆê³ ì† ì—°ì‚¬ (5ë°° ë¹ ë¦„)")
print("- 100% ì •í™•ë„ ìë™ ì¡°ì¤€")
print("- ë¬´ì¡°ê±´ í—¤ë“œìƒ·")
print("- í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì§€ì›")
print("========================================")

runService.RenderStepped:Connect(function(deltaTime)
    if not SETTINGS.MASTER_SWITCH then return end
    
    -- íƒ€ê²Ÿ ì—…ë°ì´íŠ¸
    Target, TargetPart = FindBestTarget()
    
    -- UI ì—…ë°ì´íŠ¸
    if MobileUI.TargetLabel then
        if Target then
            local distance = TargetPart and (TargetPart.Position - cam.CFrame.Position).Magnitude or 0
            MobileUI.TargetLabel.Text = string.format("ğŸ¯ íƒ€ê²Ÿ: %s [%.1f]", 
                Target.Parent and Target.Parent.Name or "ì ", distance)
        else
            MobileUI.TargetLabel.Text = "ğŸ¯ íƒ€ê²Ÿ: ì—†ìŒ"
        end
    end
    
    if MobileUI.StatsLabel then
        MobileUI.StatsLabel.Text = string.format("ğŸ”« ì—°ì‚¬: %dx | ğŸ“ ê±°ë¦¬: %.1f | ğŸ”¥ ë°œì‚¬: %d",
            SETTINGS.RAPID_MULTIPLIER,
            TargetPart and (TargetPart.Position - cam.CFrame.Position).Magnitude or 0,
            shotCount
        )
    end
    
    -- ìë™ ë°œì‚¬
    if MobileUI.AutoFiring and MobileUI.AutoFiring() and Target then
        -- ìë™ ë°œì‚¬ ë¡œì§
        shotCount = shotCount + 1
    end
    
    -- ESP ì—…ë°ì´íŠ¸
    if SETTINGS.ESP_ENABLED then
        for _, player in pairs(ps:GetPlayers()) do
            if player ~= lp and player.Character then
                CreateSimpleESP(player.Character)
            end
        end
    end
    
    -- ì¡°ì¤€ ë³´ì¡° ì‹¤ì‹œê°„ ì ìš©
    if SETTINGS.PERFECT_AIM and TargetPart then
        -- ì¹´ë©”ë¼ ì¡°ì¤€ ë³´ì •
        local correction = GetAimCorrection(TargetPart)
        -- ì‹¤ì œ ì¹´ë©”ë¼ ì¡°ì‘ (ê²Œì„ì— ë”°ë¼ êµ¬í˜„ ë°©ì‹ ë‹¤ë¦„)
    end
end)

-- í„°ì¹˜ ì œìŠ¤ì²˜ ê°ì§€
uis.TouchStarted:Connect(function(touch, processed)
    if processed then return end
    
    -- ë”ë¸” íƒ­: ì‹œìŠ¤í…œ í† ê¸€
    if touch.TapCount == 2 then
        SETTINGS.MASTER_SWITCH = not SETTINGS.MASTER_SWITCH
        print("ì‹œìŠ¤í…œ:", SETTINGS.MASTER_SWITCH and "í™œì„±í™”" or "ë¹„í™œì„±í™”")
    end
end)

-- ê²Œì„ ì¢…ë£Œ ì‹œ ì •ë¦¬
game.Players.LocalPlayer.CharacterRemoving:Connect(function()
    -- ESP ì •ë¦¬
    for target, esp in pairs(ESPCache) do
        if esp.Highlight then esp.Highlight:Destroy() end
        if esp.Billboard then esp.Billboard:Destroy() end
    end
    
    -- í›„í‚¹ í•´ì œ
    workspace.Raycast = nil
    workspace.FindPartOnRay = nil
    
    for remote, original in pairs(RemoteHooks) do
        if remote:IsA("RemoteEvent") then
            remote.FireServer = original
        elseif remote:IsA("RemoteFunction") then
            remote.InvokeServer = original
        end
    end
    
    if MobileUI.GUI then
        MobileUI.GUI:Destroy()
    end
end)

-- ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ ë³´ì¥
task.spawn(function()
    while true do
        task.wait(1)
        -- ì‹œìŠ¤í…œì´ êº¼ì ¸ìˆì–´ë„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìœ ì§€
    end
end)
